# Vector

В этой задаче вам нужно реализовать упрощенный аналог класса `std::vector`. Для этого определите класс `Vector`, в котором
будут храниться инты и есть:

#### Конструкторы и деструктор
* По умолчанию, создающий вектор с нулевыми `Size` и `Capacity`
* Принимающий размер вектора и заполняющий его нулями
* Принимающий список инициализации `std::initializer_list<int>`, что позволяет писать `Vector a{1, 3, 5}`
* Копирования
* Деструктор

#### Операторы
* Присваивания
* Сравнения на равенство и неравенство `==` и `!=`
* Трехстороннего сравнения ("космический корабль") `<=>`, выполняющий лексикографическое сравнение векторов.
* Обращение по индексу `[]`, константный и неконстантный. Последний должен позволять изменять содержимое по индексу.

#### Методы 
* `Size`, возвращающий число элементов в векторе.
* `Capacity`, возвращающий текущее число выделенных ячеек памяти под вектор.
* `PushBack`, который вставляет элемент в конец вектора. Если при этом память, выделенная для вектора, заполнена, то выполните
  реаллокацию: выделите массив вдвое большего размера, скопируйте элементы туда, после чего удалите старый массив. В
  этом случае `Capacity` также должен увеличиться вдвое. Частным случаем является первое добавление элемента в пустой (с `Capacity` == 0) вектор - в этом случае выделите память под один элемент.
* `PopBack`, который удаляет последний элемент вектора. Сужать вектор при этом не нужно, должен измениться только `Size`.
* `Clear`, очищающий вектор. Аналогично, сужать его при этом не нужно, `Size` должен стать нулевым.
* `Reserve`, который принимает новое значение `capacity`, позволяя зарезервировать место в векторе. Если текущий `Capacity` не
  меньше переданного, то метод не должен ничего делать. В противном случае выполните реаллокацию в массив размера `capacity`.
* `Data`, возвращающий указатель на внутренний массив вектора.
* `Swap`, принимающий другой вектор по ссылке и меняющий содержимое текущего вектора с ним местами. При этом не должно происходить выделение динамической памяти.
* `Begin` и `End`, возвращающие итераторы на первый элемент вектора и следующий за последним. Также определите их аналоги
  `begin` и `end`, чтобы c вашим вектором можно было работать с помощью range-based for.

`Iterator` должен удовлетворять требованиям к [RandomAccessIterator](https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator).

### Примечания

* В этой задаче вам запрещено использовать стандартные контейнеры и умные указатели, поэтому аккуратно управляйте памятью.
* Если в какой-то момент не удалось выделить память, из оператора/метода должно быть выброшено соответствующее исключение, а все объекты должны  
  остаться в том состоянии, в которм они были до вызова оператора/метода.
* `Iterator` должен быть неконстантным, т.е. с его помощью можно изменять элементы последовательности (см. тесты).
* Обратите внимание, что range-based for работает с коллекцией только в том случае, если в ней есть методы `begin` и `end` или определены
  внешние функции `begin` и `end`, принимающие заданную коллекцию. Именно поэтому мы дополнительно определяем эти методы в классе с именами,
  не соответствующими стайлгайду.
  При этом clang-tidy не разрешит вам сделать методы с такими именами, поэтому используйте комментарий `// NOLINT` после объявления метода.
